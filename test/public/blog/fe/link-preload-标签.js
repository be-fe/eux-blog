webpackJsonp([31,40],{919:function(e,n){e.exports={content:'<p>本文主要对 Preload 这一新标准介绍。目前 Preload 兼容性如下：  </p>\n<p><img src="https://raw.githubusercontent.com/T-phantom/T-phantom.github.io/master/images/preload_state.png"></p>\n<h2 id="preload-标签是什么"><a href="#preload-%E6%A0%87%E7%AD%BE%E6%98%AF%E4%BB%80%E4%B9%88" aria-hidden="true"><span class="icon icon-link"></span></a>Preload 标签是什么</h2>\n<p>Preload 作为一个新的web标准，旨在提高性能和为web开发人员提供更细粒度的加载控制。Preload使开发者能够自定义资源的加载逻辑，且无需忍受基于脚本的资源加载器带来的性能损失。  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="preload">\n</code></pre>\n<h2 id="类似的技术"><a href="#%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%8A%80%E6%9C%AF" aria-hidden="true"><span class="icon icon-link"></span></a>类似的技术</h2>\n<p>关于预加载，目前已经有几种方案  </p>\n<h3 id="dns-prefetch"><a href="#dns-prefetch" aria-hidden="true"><span class="icon icon-link"></span></a>DNS prefetch</h3>\n<p>DNS prefetching通过指定具体的URL来告知客户端未来会用到相关的资源，这样浏览器可以尽早的解析DNS。比如我们需要一个在example.com的图片或者视频文件。在“就可以这么写：  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="dns-prefetch" href="//example.com">\n</code></pre>\n<h3 id="preconnect"><a href="#preconnect" aria-hidden="true"><span class="icon icon-link"></span></a>Preconnect</h3>\n<p>和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）。用法如下：  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="preconnect" href="http://example.com"> \n</code></pre>\n<h3 id="prefetch"><a href="#prefetch" aria-hidden="true"><span class="icon icon-link"></span></a>Prefetch</h3>\n<p>当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用。prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="prefetch" href="image.png">\n</code></pre>\n<h3 id="subresource"><a href="#subresource" aria-hidden="true"><span class="icon icon-link"></span></a>Subresource</h3>\n<p>subresource可以用来指定资源是最高优先级的。比如，在Chrome和Opera中我们可以加上下面的代码：  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="subresource" href="styles.css">  \n</code></pre>\n<h3 id="prerender"><a href="#prerender" aria-hidden="true"><span class="icon icon-link"></span></a>Prerender</h3>\n<p>prerender是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="prerender" href="/thenextpage.html"/>\n</code></pre>\n<h2 id="preload-的优势"><a href="#preload-%E7%9A%84%E4%BC%98%E5%8A%BF" aria-hidden="true"><span class="icon icon-link"></span></a>Preload 的优势</h2>\n<p>相对于类似的技术，Preload 有 as 属性，这让浏览器可做一些 subresource 和 prefetch 无法实现的事：  </p>\n<ul>\n<li>浏览器可以设置正确的资源加载优先级</li>\n<li>浏览器可以确保请求是符合内容安全策略的  </li>\n<li>浏览器能根据 as 的值发送适当的 Accept 头部信息  </li>\n<li>浏览器通过 as 值能得知资源类型  </li>\n</ul>\n<p>Preload 的与众不同还体现在 onload 事件上（在 Chrome 中，prefetch 和 subresource 是不支持的）。preload 不会阻塞 windows 的 onload 事件，除非，preload资源的请求刚好来自于会阻塞 window 加载的资源。  </p>\n<h2 id="preload-用法举例"><a href="#preload-%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B" aria-hidden="true"><span class="icon icon-link"></span></a>Preload 用法举例</h2>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="preload" href="a.js" as="script">\n</code></pre>\n<p>忽略 as 属性，或者错误的 as 属性会使 preload 等同于 XHR 请求，浏览器不知道加载的是什么，  </p>\n<p>因此会赋予此类资源非常低的加载优先级。  </p>\n<h2 id="preload-应用"><a href="#preload-%E5%BA%94%E7%94%A8" aria-hidden="true"><span class="icon icon-link"></span></a>Preload 应用</h2>\n<h3 id="对字体的提前加载"><a href="#%E5%AF%B9%E5%AD%97%E4%BD%93%E7%9A%84%E6%8F%90%E5%89%8D%E5%8A%A0%E8%BD%BD" aria-hidden="true"><span class="icon icon-link"></span></a>对字体的提前加载</h3>\n<p>字体被隐藏在css中间，浏览器有时候不能很好的将他们放入预加载器中，为此我们可以借助preload  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="preload" href="font.woff" as="font" type="font/woff" crossorigin>\n</code></pre>\n<p>crossorigin 属性是必须的，即便是字体资源在自家服务器上，因为用户代理必须采用匿名模式来获取字体资源。  </p>\n<h3 id="基于标记语言的异步加载"><a href="#%E5%9F%BA%E4%BA%8E%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD" aria-hidden="true"><span class="icon icon-link"></span></a>基于标记语言的异步加载</h3>\n<p>css 异步加载  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="preload" as="style" href="asyncstyle.css" onload="this.rel=\'stylesheet\'">\n</code></pre>\n<p>js 异步加载  </p>\n<pre><code data-query="{}" data-lang="">&#x3C;link rel="preload" as="script" href="async_script.js" onload="var script = document.createElement(\'script\'); script.src = this.href; document.body.appendChild(script);">\n</code></pre>\n<p>async 属性会阻塞 window 的 onload 事件，这么写就没有问题了。  </p>\n<h3 id="动态加载，但不执行"><a href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%89%A7%E8%A1%8C" aria-hidden="true"><span class="icon icon-link"></span></a>动态加载，但不执行</h3>\n<pre><code data-query="{}" data-lang="">var link = document.createElement("link");\nlink.href = "myscript.js";\nlink.rel = "preload";\nlink.as = "script";\ndocument.head.appendChild(link);\nvar script = document.createElement("script");\nscript.src = "myscript.js";\ndocument.body.appendChild(script); \n</code></pre>\n<h2 id="检测是否支持-preload"><a href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-preload" aria-hidden="true"><span class="icon icon-link"></span></a>检测是否支持 preload</h2>\n<p>用下面的代码段可以检测是否被支持：  </p>\n<pre><code data-query="{}" data-lang="">const preloadSupported = () => {\n    const link = document.createElement(\'link\');\n    const relList = link.relList;\n    if (!relList || !relList.supports)\n        return false;\n    return relList.supports(\'preload\');\n};\n</code></pre>\n<h2 id="preload-在生产环境的案例"><a href="#preload-%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E6%A1%88%E4%BE%8B" aria-hidden="true"><span class="icon icon-link"></span></a>Preload 在生产环境的案例</h2>\n<h3 id="treebo-案例"><a href="#treebo-%E6%A1%88%E4%BE%8B" aria-hidden="true"><span class="icon icon-link"></span></a>Treebo 案例</h3>\n<p>Treebo，印度最大的旅馆网站之一，在 3G 网络下对其桌面版试验，在对其顶部图片和主要的 Webpack 打包文件使用 preload 之后，在首屏绘制和可交互延迟分别减少了 1s。  </p>\n<p><img src="https://raw.githubusercontent.com/T-phantom/T-phantom.github.io/master/images/preload%E6%A1%88%E4%BE%8B1.png"></p>\n<p>同样的，在对自己的渐进式 Web 应用程序主要打包文件使用 preload 之后，Flipkart 在路由解析之前 节省了大量的主线程空闲时间（在 3G 网络下的低性能手机下）。  </p>\n<h1 id="参考文献"><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" aria-hidden="true"><span class="icon icon-link"></span></a>参考文献</h1>\n<ul>\n<li><a href="https://mp.weixin.qq.com/s/O5E2ASBEzfKOxgzCCJDlfw">深入研究Chrome：Preload与Prefetch原理，及其优先级</a>  </li>\n<li><a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/">Preload: What Is It Good For?</a></li>\n</ul>\n',extra:{}}}});